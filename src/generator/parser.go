// Code generated by goyacc -o parser.go -p Leo leo.y. DO NOT EDIT.

//line leo.y:13

package generator

import __yyfmt__ "fmt"

//line leo.y:14

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"log"
	"math/big"
	"os"
	"regexp"
	"unicode/utf8"
)

type Pos struct {
	Line   int
	Column int
}

const LEX_ERROR = -1

type Node struct {
	Parent   *Node
	Children []*Node
	Value    string
	Position Pos
	Buffer   *bytes.Buffer
	Rule     string
	BigInt   *big.Int
	BigFloat *big.Float
}

func NewNode(p *Node, name string, yylval *LeoSymType) *Node {
	var n *Node
	n = &Node{Parent: p, Rule: name, Children: make([]*Node, 0), Buffer: bytes.NewBufferString("")}
	if yylval != nil {
		n.Position.Line = yylval.Tokenline
		n.Position.Column = yylval.Tokencolumn
		n.Value = yylval.Tokenstring
		n.Buffer.WriteString(yylval.Tokenstring)
		n.BigInt = yylval.Tokenint
		n.BigFloat = yylval.Tokenfloat
	}
	return n
}

func (n *Node) AddChild(c *Node) *Node {
	c.Parent = n
	n.Children = append(n.Children, c)
	return n
}

//line leo.y:69
type LeoSymType struct {
	yys               int
	Tokentype         int
	Tokenrule         int
	Tokensubtype      int
	Tokenbuffer       *bytes.Buffer
	Tokenstring       string
	Tokenname         string
	Tokenline         int
	Tokencolumn       int
	Tokenpackage      string
	Tokennode         *Node
	Tokensymbol_index int
	Tokenerror        error
	Tokenint          *big.Int
	Tokenfloat        *big.Float
}

const INT = 57346
const FLOAT = 57347
const IMAGINARY = 57348
const HEX = 57349
const OCTAL = 57350
const BINARY = 57351
const STRING_LITERAL = 57352
const CHAR_LITERAL = 57353
const RUNE_LITERAL = 57354
const WHITESPACE = 57355
const TAB = 57356
const NEWLINE = 57357
const COMMENT = 57358
const IDENTIFIER = 57359
const PACKAGE = 57360
const IMPORT = 57361
const FUNC = 57362
const VAR = 57363
const CONST = 57364
const TYPE = 57365
const STRUCT = 57366
const INTERFACE = 57367
const MAP = 57368
const CHANNEL = 57369
const LAUNCH = 57370
const SELECT = 57371
const CASE = 57372
const DEFAULT = 57373
const FOR = 57374
const RANGE = 57375
const BREAK = 57376
const CONTINUE = 57377
const GOTO = 57378
const IF = 57379
const ELSE = 57380
const SWITCH = 57381
const RETURN = 57382
const FALLTHROUGH = 57383
const SAFE = 57384
const INT_TYPE = 57385
const INT8_TYPE = 57386
const INT16_TYPE = 57387
const INT32_TYPE = 57388
const INT64_TYPE = 57389
const UINT_TYPE = 57390
const UINT8_TYPE = 57391
const UINT16_TYPE = 57392
const UINT32_TYPE = 57393
const UINT64_TYPE = 57394
const FLOAT_TYPE = 57395
const FLOAT16_TYPE = 57396
const FLOAT32_TYPE = 57397
const FLOAT64_TYPE = 57398
const COMPLEX_TYPE = 57399
const COMPLEX16_TYPE = 57400
const COMPLEX32_TYPE = 57401
const COMPLEX64_TYPE = 57402
const BOOL_TYPE = 57403
const STRING_TYPE = 57404
const BYTE_TYPE = 57405
const RUNE_TYPE = 57406
const CHAR_TYPE = 57407
const ERROR_TYPE = 57408
const SEMICOLON = 57409
const COLON = 57410
const COMMA = 57411
const PERIOD = 57412
const ELLIPSIS = 57413
const STAR = 57414
const AMPERSAND = 57415
const LBRACK = 57416
const RBRACK = 57417
const LBRACE = 57418
const RBRACE = 57419
const LPAREN = 57420
const RPAREN = 57421
const LANGLE = 57422
const RANGLE = 57423
const ASSIGN = 57424
const NEW_ASSIGN = 57425
const ADD_ASSIGN = 57426
const SUB_ASSIGN = 57427
const MUL_ASSIGN = 57428
const QUO_ASSIGN = 57429
const REM_ASSIGN = 57430
const AND_ASSIGN = 57431
const OR_ASSIGN = 57432
const PLUS = 57433
const MINUS = 57434
const MUL = 57435
const DIV = 57436
const MOD = 57437
const SHL = 57438
const SHR = 57439
const AND = 57440
const OR = 57441
const NOT = 57442
const EQ = 57443
const NEQ = 57444
const LT = 57445
const GT = 57446
const LTE = 57447
const GTE = 57448
const NOT_AND = 57449
const NOT_OR = 57450
const SHL_ROTATE = 57451
const SHR_ROTATE = 57452
const BITWISE_AND = 57453
const BITWISE_OR = 57454
const BITWISE_XOR = 57455
const BITWISE_NOT = 57456
const NOT_EQ = 57457
const EOF = 57458
const ILLEGAL = 57459
const COMMENT_START = 57460
const COMMENT_END = 57461
const COMMENT_LINE = 57462
const COMMENT_BLOCK = 57463
const COMMENT_DOC = 57464
const BRIDGE = 57465
const CHANNEL_SEND = 57466
const CHANNEL_RECEIVE = 57467
const CHANNEL_CLOSE = 57468
const CHANNEL_SELECT = 57469
const TRANSFER = 57470
const POINTER = 57471
const REFERENCE = 57472
const INDIRECT = 57473
const TERMINAL = 57474

var LeoToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"INT",
	"FLOAT",
	"IMAGINARY",
	"HEX",
	"OCTAL",
	"BINARY",
	"STRING_LITERAL",
	"CHAR_LITERAL",
	"RUNE_LITERAL",
	"WHITESPACE",
	"TAB",
	"NEWLINE",
	"COMMENT",
	"IDENTIFIER",
	"PACKAGE",
	"IMPORT",
	"FUNC",
	"VAR",
	"CONST",
	"TYPE",
	"STRUCT",
	"INTERFACE",
	"MAP",
	"CHANNEL",
	"LAUNCH",
	"SELECT",
	"CASE",
	"DEFAULT",
	"FOR",
	"RANGE",
	"BREAK",
	"CONTINUE",
	"GOTO",
	"IF",
	"ELSE",
	"SWITCH",
	"RETURN",
	"FALLTHROUGH",
	"SAFE",
	"INT_TYPE",
	"INT8_TYPE",
	"INT16_TYPE",
	"INT32_TYPE",
	"INT64_TYPE",
	"UINT_TYPE",
	"UINT8_TYPE",
	"UINT16_TYPE",
	"UINT32_TYPE",
	"UINT64_TYPE",
	"FLOAT_TYPE",
	"FLOAT16_TYPE",
	"FLOAT32_TYPE",
	"FLOAT64_TYPE",
	"COMPLEX_TYPE",
	"COMPLEX16_TYPE",
	"COMPLEX32_TYPE",
	"COMPLEX64_TYPE",
	"BOOL_TYPE",
	"STRING_TYPE",
	"BYTE_TYPE",
	"RUNE_TYPE",
	"CHAR_TYPE",
	"ERROR_TYPE",
	"SEMICOLON",
	"COLON",
	"COMMA",
	"PERIOD",
	"ELLIPSIS",
	"STAR",
	"AMPERSAND",
	"LBRACK",
	"RBRACK",
	"LBRACE",
	"RBRACE",
	"LPAREN",
	"RPAREN",
	"LANGLE",
	"RANGLE",
	"ASSIGN",
	"NEW_ASSIGN",
	"ADD_ASSIGN",
	"SUB_ASSIGN",
	"MUL_ASSIGN",
	"QUO_ASSIGN",
	"REM_ASSIGN",
	"AND_ASSIGN",
	"OR_ASSIGN",
	"PLUS",
	"MINUS",
	"MUL",
	"DIV",
	"MOD",
	"SHL",
	"SHR",
	"AND",
	"OR",
	"NOT",
	"EQ",
	"NEQ",
	"LT",
	"GT",
	"LTE",
	"GTE",
	"NOT_AND",
	"NOT_OR",
	"SHL_ROTATE",
	"SHR_ROTATE",
	"BITWISE_AND",
	"BITWISE_OR",
	"BITWISE_XOR",
	"BITWISE_NOT",
	"NOT_EQ",
	"EOF",
	"ILLEGAL",
	"COMMENT_START",
	"COMMENT_END",
	"COMMENT_LINE",
	"COMMENT_BLOCK",
	"COMMENT_DOC",
	"BRIDGE",
	"CHANNEL_SEND",
	"CHANNEL_RECEIVE",
	"CHANNEL_CLOSE",
	"CHANNEL_SELECT",
	"TRANSFER",
	"POINTER",
	"REFERENCE",
	"INDIRECT",
	"TERMINAL",
}

var LeoStatenames = [...]string{}

const LeoEofCode = 1
const LeoErrCode = 2
const LeoInitialStackSize = 16

//line leo.y:866

// The parser expects the lexer to return 0 on EOF.
const eof = 0
const LEX_NORMAL = 0
const LEX_COMMENT = 1
const LEX_STRING = 2
const UNDEFINED = -3

// The parser uses the type <prefix>Lex as a lexer. It must provide
// the methods Lex(*<prefix>SymType) int and Error(string).
type LeoLex struct {
	//Lex Stream
	Source  []byte
	Stream  []byte
	peek    rune
	Line    int
	Column  int
	Index   int
	Sz      int
	LexMode int

	//Regex Compiled Expressions
	reWhitespace        *regexp.Regexp
	reSingleLineComment *regexp.Regexp
	reMultiLineComment  *regexp.Regexp
	reTerminator        *regexp.Regexp

	//Regex Decimal Patterns
	reInt       *regexp.Regexp
	reFloat     *regexp.Regexp
	reImaginary *regexp.Regexp
	reHex       *regexp.Regexp
	reOctal     *regexp.Regexp
	reBinary    *regexp.Regexp

	//Regex String Patterns
	reString     *regexp.Regexp
	reCharString *regexp.Regexp

	//Regex Keyword Patterns
	reKeyword       *regexp.Regexp
	reSpecialTokens *regexp.Regexp
	reIdentifier    *regexp.Regexp
}

// The parser yaccpar calls this method to get each new token.
func (x *LeoLex) Lex(yylval *LeoSymType) int {

	var tokens [7]int
	var token int
	var c rune
	x.ResetPeek()
	c = x.Peek()
	fmt.Printf("Lexing: %c\n", c)
	if c == eof {
		fmt.Printf("EOF\n")
		return EOF
	}

	tokens[0] = x.LexWhitespace(yylval)
	if tokens[0] != ILLEGAL {
		fmt.Println("Whitespace Found ")
		token = tokens[0]
		goto increment_char
	}

	tokens[1] = x.LexComments(yylval)
	if tokens[1] != ILLEGAL {
		fmt.Printf("Comments Found ")
		token = tokens[1]
		goto increment_char
	}

	tokens[2] = x.LexKeywords(yylval)
	if tokens[2] != ILLEGAL {
		fmt.Printf("Keywords Found ")
		token = tokens[2]
		goto increment_char
	}
	tokens[3] = x.LexNumbers(yylval)
	if tokens[3] != ILLEGAL {
		fmt.Printf("Numbers Found ")
		token = tokens[3]
		goto increment_char
	}
	tokens[4] = x.LexMultiTokens(yylval)
	if tokens[4] != ILLEGAL {
		fmt.Printf("Multi Tokens Found ")
		token = tokens[4]
		goto increment_char
	}
	tokens[5] = x.LexSimpleToken(c, yylval)
	if tokens[5] != ILLEGAL {
		fmt.Printf("Simple Tokens Found ")
		token = tokens[5]
		goto increment_char
	}
	tokens[6] = x.LexIdentifiers(yylval)
	if tokens[6] != ILLEGAL {
		fmt.Printf("Identifiers Found ")
		token = tokens[6]
		goto increment_char
	}

increment_char:
	fmt.Printf("Incrementing Char\n ")
	x.Next(yylval)
	return token

	return token
}

func (x *LeoLex) LexWhitespace(yylval *LeoSymType) int {
	// Lex Whitesapce and Comments with RegEx
	whitespacePattern := `^([\s\t\n\r]+)`
	var err error

	// Compile the regex patterns
	if x.reWhitespace == nil {
		x.reWhitespace, err = regexp.Compile(whitespacePattern)
	}

	// Check Regex Compile Errors
	if err != nil {
		log.Fatalf("Bad Regexp: LexWhitespaceComments()\n %s", err.Error())
	}

	// Search for the longest matching string and return the token or eof
	whitespaceFindBytes := x.reWhitespace.Find(x.Stream)

	if whitespaceFindBytes != nil {
		if x.reWhitespace.FindIndex(x.Stream)[0] == 0 {
			if x.LexMode == LEX_NORMAL {
				x.Stream = x.Stream[len(whitespaceFindBytes):]
				return WHITESPACE
			}
		}
	}
	x.ResetPeek()
	return ILLEGAL
}

func (x *LeoLex) LexComments(yylval *LeoSymType) int {

	// Lex Whitesapce and Comments with RegEx
	singleLineCommentPattern := `^(\/\/.*)`
	multiLineCommentPattern := `^(\/\*.*\*\/)`
	var err error

	// Compile the regex patterns
	if x.reSingleLineComment == nil {
		x.reSingleLineComment, err = regexp.Compile(singleLineCommentPattern)
	}
	if x.reMultiLineComment == nil {
		x.reMultiLineComment, err = regexp.Compile(multiLineCommentPattern)
	}

	// Check Regex Compile Errors
	if err != nil {
		log.Fatalf("Bag Regexp: %s", err.Error())
	}

	singleLineCommentFindBytes := x.reSingleLineComment.Find(x.Stream)

	if singleLineCommentFindBytes != nil {
		if x.reSingleLineComment.FindIndex(x.Stream)[0] == 0 {
			x.Stream = x.Stream[len(singleLineCommentFindBytes):]
			return COMMENT
		}
	}

	multiLineCommentFindBytes := x.reMultiLineComment.Find(x.Stream)

	if multiLineCommentFindBytes != nil {
		if x.reMultiLineComment.FindIndex(x.Stream)[0] == 0 {
			x.Stream = x.Stream[len(multiLineCommentFindBytes):]
			return COMMENT_BLOCK
		}
	}

	x.ResetPeek()
	return ILLEGAL

}

func (x *LeoLex) LexKeywords(yylval *LeoSymType) int {
	var err error
	reKeywordPattern := `^(package|import|func|var|const|type|struct|interface|map|channel|launch|select|case|default|for|range|break|continue|goto|if|else|switch|return|fallthrough|safe|int|int8|int16|int32|int64|uint|uint8|uint16|uint32|uint64|float|float16|float32|float64|complex|complex16|complex32|complex64|bool|string|byte|rune|char|error)`
	if x.reKeyword == nil {
		x.reKeyword, err = regexp.Compile(reKeywordPattern)
	}

	if err != nil {
		log.Fatalf("Bad Regexp: %s", err.Error())
	}

	keywordFindBytes := x.reKeyword.Find(x.Stream)

	if keywordFindBytes != nil {
		location := x.reKeyword.FindIndex(x.Stream)
		if location[0] == 0 {
			//Now match and return the specific keywords
			keyword := x.Stream[:location[1]]
			keyword_string := string(keyword)
			x.Stream = x.Stream[len(keywordFindBytes):]
			yylval.Tokenstring = keyword_string
			x.ResetPeek()

			switch keyword_string {
			case "package":
				fmt.Println(" ($package)")
				return PACKAGE
			case "import":
				fmt.Println(" ($import)")
				return IMPORT
			case "func":
				fmt.Println(" ($func)")
				return FUNC
			case "var":
				return VAR
			case "const":
				return CONST
			case "type":
				return TYPE
			case "struct":
				return STRUCT
			case "interface":
				return INTERFACE
			case "map":
				return MAP
			case "channel":
				return CHANNEL
			case "launch":
				return LAUNCH
			case "select":
				return SELECT
			case "case":
				return CASE
			case "default":
				return DEFAULT
			case "for":
				return FOR
			case "range":
				return RANGE
			case "break":
				return BREAK
			case "continue":
				return CONTINUE
			case "goto":
				return GOTO
			case "if":
				return IF
			case "else":
				return ELSE
			case "switch":
				return SWITCH
			case "return":
				return RETURN
			case "fallthrough":
				return FALLTHROUGH
			case "safe":
				return SAFE
			default:
				return ILLEGAL
			}
		}
	}
	return ILLEGAL
}

func (x *LeoLex) LexSimpleToken(c rune, yylval *LeoSymType) int {
	switch c {
	case '*':
		yylval.Tokenstring = string(c)
		return STAR
	case '[':
		yylval.Tokenstring = string(c)
		return LBRACK
	case ']':
		yylval.Tokenstring = string(c)
		return RBRACK
	case '{':
		yylval.Tokenstring = string(c)
		return LBRACE
	case '}':
		yylval.Tokenstring = string(c)
		return RBRACE
	case '(':
		yylval.Tokenstring = string(c)
		return LPAREN
	case ')':
		yylval.Tokenstring = string(c)
		return RPAREN
	case '=':
		yylval.Tokenstring = string(c)
		return ASSIGN
	case '+':
		yylval.Tokenstring = string(c)
		return PLUS
	case '-':
		yylval.Tokenstring = string(c)
		return MINUS
	case '/':
		yylval.Tokenstring = string(c)
		return DIV
	case '%':
		yylval.Tokenstring = string(c)
		return MOD
	case '!':
		yylval.Tokenstring = string(c)
		return NOT
	case '<':
		yylval.Tokenstring = string(c)
		return LT
	case '>':
		yylval.Tokenstring = string(c)
		return GT
	case '&':
		yylval.Tokenstring = string(c)
		return AMPERSAND
	case '|':
		yylval.Tokenstring = string(c)
		return BITWISE_OR
	case '^':
		yylval.Tokenstring = string(c)
		return BITWISE_XOR
	case '~':
		yylval.Tokenstring = string(c)
		return BITWISE_NOT
	case '\n':
		yylval.Tokenstring = string(c)
		x.Line++
		x.Column = 0
		yylval.Tokenline = x.Line
		yylval.Tokencolumn = x.Column
		return NEWLINE
	case ';':
		yylval.Tokenstring = string(c)
		return SEMICOLON
	}

	return ILLEGAL
}

func (x *LeoLex) LexMultiTokens(yylval *LeoSymType) int {
	// Lex Operators and Punctuation with RegEx
	reSpecialTokensPattern := `^(:= | += | \.\.\. |-= | *= | /= | %= | &= | << | >> | == | != | !== |<= | >= | && | || | << | >>  <- | <-->)`
	var err error
	var b *bytes.Buffer
	b = bytes.NewBufferString("")
	// Compile the regex patterns
	if x.reSpecialTokens == nil {
		x.reSpecialTokens, err = regexp.Compile(reSpecialTokensPattern)
	}

	// Check Regex Compile Errors
	if err != nil {
		log.Fatalf("Bad Regexp: %s", err.Error())
	}

	// Search for the longest matching string and return the token or eof
	specialTokensFindBytes := x.reSpecialTokens.Find(x.Stream)
	if specialTokensFindBytes != nil {
		location := x.reSpecialTokens.FindIndex(x.Stream)
		if location[0] == 0 {
			x.Stream = x.Stream[len(specialTokensFindBytes):]
			b.Write(specialTokensFindBytes)
			yylval.Tokenbuffer = b
			Tokenstring := string(specialTokensFindBytes)
			yylval.Tokenstring = Tokenstring
			x.ResetPeek()

			switch Tokenstring {

			case "...":
				return ELLIPSIS
			case ":=":
				return NEW_ASSIGN
			case "+=":
				return ADD_ASSIGN
			case "-=":
				return SUB_ASSIGN
			case "*=":
				return MUL_ASSIGN
			case "/=":
				return QUO_ASSIGN
			case "%=":
				return REM_ASSIGN
			case "&=":
				return AND_ASSIGN
			case "!==":
				return NOT_EQ
			case "|=":
				return OR_ASSIGN
			case "==":
				return EQ
			case "!=":
				return NEQ
			case "<=":
				return LTE
			case ">=":
				return GTE
			case "&&":
				return NOT_AND
			case "||":
				return NOT_OR
			case "<<":
				return SHL_ROTATE
			case ">>":
				return SHR_ROTATE
			case "<-":
				return CHANNEL_SEND
			case "<-->":
				return CHANNEL_RECEIVE
			default:
				return ILLEGAL
			}

		}
	}
	return ILLEGAL
}

// Lex Numbers, Floats, Imaginary, Hex, Octal, Binary with RegExps
func (x *LeoLex) LexNumbers(yylval *LeoSymType) int {

	//Declare new buffer
	var b *bytes.Buffer
	b = bytes.NewBufferString("")
	var err error

	reIntPattern := `^0|[1-9][0-9]*`
	reFloatPattern := `^[0-9]+[\.][0-9]+`
	reImaginaryPattern := `^[0-9]+[i]`
	reHexPattern := `^0[xX][0-9a-fA-F]+`
	reOctalPattern := `^0c[0-7]+`
	reBinaryPattern := `^0b[01]+`

	// Compile the regex patterns
	if x.reInt == nil {
		x.reInt, err = regexp.Compile(reIntPattern)
	}
	if x.reFloat == nil {
		x.reFloat, err = regexp.Compile(reFloatPattern)
	}
	if x.reImaginary == nil {
		x.reImaginary, err = regexp.Compile(reImaginaryPattern)
	}
	if x.reHex == nil {
		x.reHex, err = regexp.Compile(reHexPattern)
	}
	if x.reOctal == nil {
		x.reOctal, err = regexp.Compile(reOctalPattern)
	}
	if x.reBinary == nil {
		x.reBinary, err = regexp.Compile(reBinaryPattern)
	}

	// Check Regex Compile Errors
	if err != nil {
		log.Fatalf("Bad Regexp: %s", err.Error())
	}

	// Search for the longest matching string and return the token or eof for float
	floatFindBytes := x.reFloat.Find(x.Stream)

	if floatFindBytes != nil {
		yylval.Tokenfloat = big.NewFloat(0)
		if x.reFloat.FindIndex(x.Stream)[0] == 0 {
			fmt.Println("($float)")
			x.Stream = x.Stream[len(floatFindBytes):]
			b.Write(floatFindBytes)
			yylval.Tokenbuffer = b
			f, _, err := big.ParseFloat(string(floatFindBytes), 10, 0, big.ToNearestEven)
			if yylval.Tokenfloat == nil {
				log.Fatalf("Error parsing float %s", err)
			}
			yylval.Tokenfloat = f
			x.ResetPeek()
			return FLOAT
		}
	}

	hexFindBytes := x.reHex.Find(x.Stream)

	if hexFindBytes != nil {
		if x.reHex.FindIndex(x.Stream)[0] == 0 {
			x.Stream = x.Stream[len(hexFindBytes):]
			b.Write(hexFindBytes)
			yylval.Tokenbuffer = b
			x.ResetPeek()
			return HEX
		}
	}

	octalFindBytes := x.reOctal.Find(x.Stream)

	if octalFindBytes != nil {
		if x.reOctal.FindIndex(x.Stream)[0] == 0 {
			x.Stream = x.Stream[len(octalFindBytes):]
			b.Write(octalFindBytes)
			yylval.Tokenbuffer = b
			x.ResetPeek()
			return OCTAL
		}
	}

	binaryFindBytes := x.reBinary.Find(x.Stream)

	if binaryFindBytes != nil {
		if x.reBinary.FindIndex(x.Stream)[0] == 0 {
			x.Stream = x.Stream[len(binaryFindBytes):]
			b.Write(binaryFindBytes)
			yylval.Tokenbuffer = b
			x.ResetPeek()
			return BINARY
		}
	}

	// Search for the longest matching string and return the token or eof
	intFindBytes := x.reInt.Find(x.Stream)

	if intFindBytes != nil {
		yylval.Tokenint = big.NewInt(0)
		if x.reInt.FindIndex(x.Stream)[0] == 0 {
			x.Stream = x.Stream[len(intFindBytes):]
			b.Write(intFindBytes)
			intString := string(intFindBytes)
			_, result := yylval.Tokenint.SetString(intString, 10)
			if !result {
				log.Fatalf("Error parsing int")
			}
			yylval.Tokenbuffer = b
			x.ResetPeek()
			return INT
		}
	}
	return ILLEGAL
}

func (x *LeoLex) LexIdentifiers(yylval *LeoSymType) int {
	var err error
	reIdentifierPattern := `^[a-zA-Z_][a-zA-Z0-9_]*`
	if x.reIdentifier == nil {
		x.reIdentifier, err = regexp.Compile(reIdentifierPattern)
	}

	if err != nil {
		log.Fatalf("Bad Regexp: %s", err.Error())
	}

	identifierFindBytes := x.reIdentifier.Find(x.Stream)

	if identifierFindBytes != nil {
		location := x.reIdentifier.FindIndex(x.Stream)
		if location[0] == 0 {

			identifier := x.Stream[:location[1]]
			identifier_string := string(identifier)
			x.Stream = x.Stream[len(identifierFindBytes):]
			fmt.Printf("($identifier): %s", identifier_string)
			x.ResetPeek()
			yylval.Tokenstring = identifier_string
			yylval.Tokenbuffer = bytes.NewBufferString(identifier_string)
			return IDENTIFIER
		}
	}
	return ILLEGAL
}

// Peek our next rune
func (x *LeoLex) Next(yylval *LeoSymType) rune {
	if x.peek == eof {
		return eof
	}
	if len(x.Stream) == 0 {
		return eof
	}

	//Decode the rune, return it and set the peek
	c, size := utf8.DecodeRune(x.Stream)
	if c == utf8.RuneError && size == 1 {
		log.Print("invalid utf8 encoding %\b", x.Stream[0])
		x.Column++
		yylval.Tokencolumn = x.Column
		return x.Next(yylval)
	} else if c == utf8.RuneError && size == 0 {
		return eof
	} else {
		x.Column += size
		yylval.Tokencolumn += x.Column
		x.Stream = x.Stream[size:]
	}

	if len(x.Stream) > 0 {
		x.peek, _ = utf8.DecodeRune(x.Stream)
	} else {
		x.peek = eof
	}

	return c
}

func (x *LeoLex) Peek() rune {
	if x.peek == eof {
		return eof
	}
	if len(x.Stream) == 0 {
		return eof
	}
	c, _ := utf8.DecodeRune(x.Stream)
	return c
}

func (x *LeoLex) ResetPeek() {
	if len(x.Stream) > 0 {
		x.peek, _ = utf8.DecodeRune(x.Stream)
	} else {
		x.peek = eof
	}
}

// The parser calls this method on a parse error.
func (x *LeoLex) Error(s string) {
	log.Printf("parse error: %s", s)
}

func main() {
	in := bufio.NewReader(os.Stdin)
	for {
		if _, err := os.Stdout.WriteString("> "); err != nil {
			log.Fatalf("WriteString: %s", err)
		}
		line, err := in.ReadBytes('\n')
		if err == io.EOF {
			return
		}
		if err != nil {
			log.Fatalf("ReadBytes: %s", err)
		}

		LeoParse(&LeoLex{Source: line, Stream: line})
	}
}

// Lex Strings, Characters, Runes with RegExps
func (x *LeoLex) LexStrings(yylval *LeoSymType) int {

	//Declare new buffer
	var err error
	var b *bytes.Buffer
	b = bytes.NewBufferString("")

	reStringPattern := `^\".*\"`
	reCharStringPattern := `\'[a-zA-Z0-9]\'`

	// Compile the regex patterns
	if x.reString == nil {
		x.reString, err = regexp.Compile(reStringPattern)
	}
	if err != nil {
		x.reCharString, err = regexp.Compile(reCharStringPattern)
	}

	// Check Regex Compile Errors
	if x.reString == nil || x.reCharString == nil {
		log.Fatalf("Bad Regexp: %s", err.Error())
	}

	// Search for the longest matching string and return the token or eof
	stringFindBytes := x.reString.Find(x.Stream)

	if stringFindBytes != nil {
		if x.reString.FindIndex(x.Stream)[0] == 0 {
			x.Stream = x.Stream[len(stringFindBytes):]
			b.Write(stringFindBytes)
			yylval.Tokenbuffer = b
			return STRING_LITERAL
		}
	}

	charFindBytes := x.reCharString.Find(x.Stream)

	if charFindBytes != nil {
		if x.reCharString.FindIndex(x.Stream)[0] == 0 {
			x.Stream = x.Stream[len(charFindBytes):]
			b.Write(charFindBytes)
			yylval.Tokenbuffer = b
			return CHAR_LITERAL
		}
	}
	return ILLEGAL
}

//line yacctab:1
var LeoExca = [...]int8{
	-1, 1,
	1, -1,
	-2, 0,
	-1, 34,
	78, 23,
	-2, 56,
}

const LeoPrivate = 57344

const LeoLast = 993

var LeoAct = [...]int16{
	97, 286, 125, 94, 273, 96, 243, 102, 146, 53,
	247, 204, 100, 268, 253, 99, 27, 8, 252, 274,
	275, 127, 35, 29, 95, 19, 20, 21, 22, 23,
	24, 214, 73, 266, 41, 73, 29, 73, 86, 46,
	48, 73, 278, 265, 8, 144, 54, 142, 57, 101,
	129, 84, 58, 45, 52, 90, 51, 50, 74, 76,
	43, 88, 71, 8, 45, 8, 284, 77, 73, 92,
	80, 45, 45, 83, 72, 28, 43, 56, 291, 87,
	288, 130, 6, 128, 3, 145, 274, 275, 28, 90,
	89, 139, 140, 8, 26, 143, 91, 5, 93, 25,
	141, 68, 10, 65, 81, 147, 148, 178, 179, 180,
	181, 182, 183, 184, 185, 186, 187, 188, 189, 190,
	85, 32, 8, 78, 30, 31, 216, 191, 272, 69,
	196, 29, 199, 201, 205, 192, 197, 30, 31, 276,
	211, 212, 213, 206, 207, 203, 209, 210, 202, 173,
	219, 220, 221, 222, 223, 224, 225, 226, 227, 228,
	229, 230, 231, 232, 233, 234, 235, 236, 237, 238,
	239, 218, 241, 244, 245, 246, 217, 248, 249, 66,
	198, 18, 42, 28, 17, 11, 170, 200, 193, 215,
	171, 215, 242, 13, 172, 33, 139, 140, 82, 123,
	250, 258, 254, 122, 255, 141, 173, 124, 121, 120,
	119, 259, 257, 118, 117, 116, 115, 260, 44, 114,
	261, 49, 29, 113, 8, 112, 262, 111, 8, 110,
	109, 60, 30, 31, 59, 23, 24, 63, 64, 176,
	174, 98, 103, 170, 177, 79, 108, 171, 107, 106,
	267, 172, 105, 269, 270, 104, 62, 61, 277, 16,
	15, 14, 271, 12, 47, 279, 9, 244, 7, 281,
	4, 2, 1, 280, 28, 287, 0, 285, 282, 283,
	0, 0, 289, 0, 34, 36, 37, 38, 39, 40,
	193, 0, 293, 287, 295, 294, 176, 174, 139, 140,
	0, 177, 0, 0, 0, 0, 0, 141, 55, 0,
	0, 0, 0, 173, 0, 67, 70, 55, 0, 0,
	0, 75, 0, 30, 31, 0, 0, 0, 0, 0,
	67, 0, 0, 70, 0, 0, 0, 0, 55, 6,
	19, 20, 21, 22, 23, 24, 0, 0, 264, 0,
	170, 55, 0, 55, 171, 263, 0, 0, 172, 0,
	0, 0, 162, 175, 163, 164, 165, 166, 167, 168,
	169, 149, 150, 151, 152, 153, 0, 29, 0, 0,
	0, 154, 155, 156, 157, 158, 159, 160, 161, 0,
	0, 0, 194, 195, 0, 173, 0, 0, 0, 0,
	0, 208, 0, 176, 174, 0, 0, 55, 177, 55,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 28,
	0, 0, 170, 0, 0, 240, 171, 0, 0, 0,
	172, 0, 0, 0, 162, 175, 163, 164, 165, 166,
	167, 168, 169, 149, 150, 151, 152, 153, 251, 173,
	0, 0, 0, 154, 155, 156, 157, 158, 159, 160,
	161, 0, 0, 0, 0, 0, 0, 0, 30, 31,
	0, 55, 0, 0, 0, 176, 174, 0, 0, 0,
	177, 0, 0, 0, 0, 292, 170, 0, 0, 0,
	171, 0, 0, 0, 172, 0, 173, 0, 162, 175,
	163, 164, 165, 166, 167, 168, 169, 149, 150, 151,
	152, 153, 0, 0, 0, 0, 0, 154, 155, 156,
	157, 158, 159, 160, 161, 0, 0, 0, 0, 0,
	0, 0, 0, 170, 0, 0, 0, 171, 290, 176,
	174, 172, 0, 0, 177, 162, 175, 163, 164, 165,
	166, 167, 168, 169, 149, 150, 151, 152, 153, 173,
	0, 0, 0, 0, 154, 155, 156, 157, 158, 159,
	160, 161, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 176, 174, 0, 0,
	0, 177, 0, 0, 0, 0, 170, 0, 0, 0,
	171, 0, 90, 0, 172, 0, 0, 0, 162, 175,
	163, 164, 165, 166, 167, 168, 169, 149, 150, 151,
	152, 153, 173, 0, 0, 0, 0, 154, 155, 156,
	157, 158, 159, 160, 161, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 176,
	174, 0, 0, 0, 177, 0, 0, 0, 0, 170,
	0, 0, 0, 171, 0, 256, 0, 172, 0, 173,
	0, 162, 175, 163, 164, 165, 166, 167, 168, 169,
	149, 150, 151, 152, 153, 0, 0, 0, 0, 0,
	154, 155, 156, 157, 158, 159, 160, 161, 0, 0,
	0, 0, 0, 0, 0, 0, 170, 0, 0, 0,
	171, 0, 176, 174, 172, 0, 173, 177, 162, 175,
	163, 164, 165, 166, 167, 168, 169, 149, 150, 151,
	152, 153, 0, 0, 0, 0, 0, 154, 155, 156,
	157, 158, 159, 160, 161, 0, 0, 0, 0, 0,
	0, 0, 0, 170, 0, 0, 0, 171, 0, 176,
	174, 172, 0, 173, 177, 162, 175, 163, 164, 165,
	166, 167, 168, 169, 0, 0, 151, 152, 153, 0,
	0, 0, 0, 0, 154, 155, 156, 157, 158, 159,
	160, 161, 0, 0, 0, 0, 0, 0, 0, 0,
	170, 0, 0, 0, 171, 0, 176, 174, 172, 0,
	173, 177, 162, 175, 163, 164, 165, 166, 167, 168,
	169, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 154, 155, 156, 157, 158, 159, 160, 161, 0,
	0, 173, 0, 0, 0, 0, 0, 170, 0, 0,
	0, 171, 0, 176, 174, 172, 0, 0, 177, 162,
	175, 163, 164, 165, 166, 167, 168, 169, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 170, 0,
	0, 0, 171, 0, 160, 161, 172, 0, 0, 0,
	162, 175, 163, 164, 165, 166, 167, 168, 169, 8,
	176, 174, 0, 127, 0, 177, 0, 0, 0, 0,
	0, 0, 0, 0, 132, 133, 134, 135, 136, 129,
	130, 131, 126, 137, 138, 0, 0, 0, 0, 0,
	0, 176, 174, 0, 0, 0, 177, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 90, 0,
	0, 0, 0, 0, 0, 128, 0, 0, 0, 0,
	0, 0, 0, 139, 140, 0, 0, 0, 0, 0,
	0, 0, 141,
}

var LeoPact = [...]int16{
	66, -1000, 63, 76, 320, -1000, 84, 21, -1000, 5,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, 76,
	76, 76, 76, 76, 76, 21, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -14, 2, 76, 76, -14, -19,
	-20, -1000, -24, 76, 7, 76, 1, -1000, 1, 211,
	76, 76, 76, -1, -1000, 76, 76, 1, 1, -1000,
	-1000, -1000, -1000, -15, 76, 46, -1000, 76, 27, -1000,
	76, -28, -1000, 76, 1, -40, 76, 1, -1000, -1000,
	1, -1000, -1000, -17, -21, -1000, 76, -6, 76, -1000,
	892, -32, 76, -34, 8, -1000, 21, 362, 21, 21,
	21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
	21, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, 1, 207, 76, 76, 105,
	13, 105, 0, 105, 21, 21, 76, 21, 21, 105,
	105, 105, 48, 1, 48, -1000, 892, -1000, -1000, 105,
	105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
	105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
	76, 105, 105, 105, 105, -114, 105, 105, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, 362, -1000, 76, -64, -68, 536, -1000, -21, 599,
	105, 646, -1000, -1000, -1000, 536, -1000, -1000, 21, -1000,
	-1000, 693, 693, 818, -21, -1000, 76, -1000, -1000, 693,
	693, 740, 740, 740, 787, 787, 787, 787, 787, 787,
	818, 818, 173, 173, 173, 173, 173, 173, 173, 173,
	-1000, 280, -36, -1000, 646, 646, 646, 76, 646, 646,
	-1000, -69, 105, 105, 43, -1000, 56, 105, 646, -1000,
	-1000, -1000, -37, -1000, 105, -1000, 105, 1, 105, 362,
	116, -1000, -11, -1000, 105, 12, -21, 646, -1000, 473,
	-1000, 173, -1000, -1000, -1000, -1000, 10, 426, 892, -1000,
	-1000, 892, 105, 21, 21, -1000,
}

var LeoPgo = [...]int16{
	0, 272, 271, 97, 270, 185, 266, 263, 261, 260,
	259, 184, 181, 257, 256, 256, 256, 256, 256, 255,
	252, 249, 248, 246, 49, 7, 242, 241, 230, 229,
	264, 0, 229, 227, 225, 223, 219, 216, 216, 215,
	214, 213, 210, 209, 208, 207, 203, 199, 24, 5,
	3, 193, 179, 46, 9, 193, 6, 192, 192, 192,
	2, 192, 192, 192, 187, 11, 139, 1, 128, 4,
	128, 128, 182, 31, 15, 12, 103, 101, 129, 8,
	99,
}

var LeoR1 = [...]int8{
	0, 79, 79, 79, 79, 1, 2, 3, 4, 4,
	4, 80, 5, 5, 5, 5, 5, 5, 5, 6,
	6, 6, 7, 72, 72, 73, 73, 54, 54, 53,
	49, 50, 50, 48, 48, 48, 48, 48, 48, 48,
	48, 48, 48, 48, 48, 48, 48, 48, 51, 8,
	9, 10, 10, 10, 10, 10, 60, 60, 11, 12,
	76, 76, 52, 77, 77, 78, 49, 27, 27, 74,
	75, 24, 24, 25, 25, 26, 68, 68, 69, 69,
	67, 67, 19, 64, 64, 64, 64, 64, 65, 65,
	65, 66, 66, 20, 21, 22, 23, 28, 29, 31,
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
	31, 31, 31, 31, 33, 33, 33, 34, 34, 34,
	34, 34, 35, 35, 35, 35, 35, 35, 35, 35,
	36, 36, 36, 36, 36, 36, 36, 36, 37, 39,
	40, 41, 42, 13, 62, 63, 71, 45, 14, 43,
	44, 46, 47, 55, 32, 56, 57, 57, 61, 61,
	30, 38, 18, 17, 15, 16, 58, 59, 70,
}

var LeoR2 = [...]int8{
	0, 1, 1, 1, 1, 4, 3, 3, 0, 1,
	2, 1, 1, 1, 1, 1, 1, 1, 1, 0,
	1, 2, 7, 0, 3, 1, 3, 1, 3, 2,
	3, 1, 3, 2, 2, 2, 2, 2, 2, 2,
	2, 2, 2, 2, 2, 2, 2, 2, 10, 3,
	3, 4, 4, 4, 4, 4, 1, 3, 5, 5,
	1, 2, 2, 1, 2, 6, 3, 3, 2, 5,
	5, 3, 4, 2, 3, 5, 1, 2, 4, 3,
	1, 3, 5, 0, 1, 1, 1, 1, 0, 1,
	1, 1, 1, 3, 2, 2, 3, 2, 2, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 2, 2, 2, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 4, 3,
	4, 6, 4, 5, 3, 5, 3, 3, 2, 3,
	4, 3, 3, 2, 3, 1, 1, 3, 1, 3,
	1, 3, 3, 4, 2, 3, 3, 5, 3,
}

var LeoChk = [...]int16{
	-1000, -1, -2, 18, -4, -3, 19, -30, 17, -6,
	-3, -5, -7, -51, -8, -9, -10, -11, -12, 20,
	21, 22, 23, 24, 25, -80, 10, -79, 67, 15,
	116, 117, 116, -5, -30, -60, -30, -30, -30, -30,
	-30, -79, -72, 74, -72, 70, -60, -30, -60, -72,
	76, 76, 78, -54, -53, -30, 70, -60, -60, -11,
	-12, -13, -14, 26, 27, -76, -52, -30, -77, -78,
	-30, -54, 75, 69, -60, -30, 74, -60, 77, -52,
	-60, 77, -78, -60, 79, -53, 78, -60, 78, -49,
	76, -54, 75, -54, -50, -48, -49, -31, -27, -74,
	-75, -24, -25, -26, -19, -20, -21, -22, -23, -28,
	-29, -33, -34, -35, -36, -37, -39, -40, -41, -42,
	-43, -44, -46, -47, -45, -60, 40, 21, 83, 37,
	38, 39, 32, 33, 34, 35, 36, 41, 42, 91,
	92, 100, 79, -60, 79, 77, -79, -79, -79, 91,
	92, 93, 94, 95, 101, 102, 103, 104, 105, 106,
	107, 108, 82, 84, 85, 86, 87, 88, 89, 90,
	70, 74, 78, 33, 124, 83, 123, 128, -79, -79,
	-79, -79, -79, -79, -79, -79, -79, -79, -79, -79,
	-79, -31, -79, 83, -30, -30, -31, -49, -24, -31,
	-64, -31, -74, -75, -65, -31, -79, -79, -30, -79,
	-79, -31, -31, -31, -73, -53, 78, -73, -48, -31,
	-31, -31, -31, -31, -31, -31, -31, -31, -31, -31,
	-31, -31, -31, -31, -31, -31, -31, -31, -31, -31,
	-30, -31, -57, -56, -31, -31, -31, 124, -31, -31,
	-79, -30, 82, 82, -49, -49, 76, -65, -31, -49,
	-79, -49, -54, 75, 68, 79, 69, -60, 82, -31,
	-31, -25, -68, -69, 30, 31, -66, -31, 79, -31,
	-56, -31, -79, -79, 77, -69, -67, -31, 68, -49,
	75, 68, 69, -50, -50, -67,
}

var LeoDef = [...]int16{
	0, -2, 8, 0, 19, 9, 0, 0, 160, 0,
	10, 20, 12, 13, 14, 15, 16, 17, 18, 0,
	0, 0, 0, 0, 0, 0, 11, 6, 1, 2,
	3, 4, 5, 21, -2, 0, 0, 0, 23, 0,
	0, 7, 0, 0, 0, 0, 49, 56, 50, 0,
	0, 0, 0, 0, 27, 0, 0, 57, 51, 52,
	53, 54, 55, 0, 0, 0, 60, 0, 0, 63,
	0, 0, 24, 0, 29, 0, 0, 148, 58, 61,
	62, 59, 64, 0, 0, 28, 0, 0, 0, 22,
	0, 0, 0, 0, 0, 31, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 99, 100, 101, 102, 103, 104, 105, 106, 107,
	108, 109, 110, 111, 112, 113, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 143, 0, 30, 0, 33, 34, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 35, 36,
	37, 38, 39, 40, 41, 42, 43, 44, 45, 46,
	47, 0, 68, 0, 0, 0, 0, 73, 0, 0,
	0, 84, 85, 86, 87, 0, 94, 95, 0, 97,
	98, 114, 115, 116, 0, 25, 0, 65, 32, 117,
	118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
	128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
	139, 0, 0, 156, 155, 147, 149, 0, 151, 152,
	67, 0, 0, 0, 71, 74, 0, 0, 89, 93,
	96, 48, 0, 140, 0, 142, 0, 150, 0, 0,
	138, 72, 0, 76, 0, 0, 0, 91, 26, 0,
	157, 138, 69, 70, 75, 77, 0, 80, 0, 82,
	141, 0, 0, 79, 78, 81,
}

var LeoTok1 = [...]int8{
	1,
}

var LeoTok2 = [...]uint8{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
	52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
	62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
	72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
	82, 83, 84, 85, 86, 87, 88, 89, 90, 91,
	92, 93, 94, 95, 96, 97, 98, 99, 100, 101,
	102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
	112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
	122, 123, 124, 125, 126, 127, 128, 129, 130, 131,
	132,
}

var LeoTok3 = [...]int8{
	0,
}

var LeoErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	LeoDebug        = 0
	LeoErrorVerbose = false
)

type LeoLexer interface {
	Lex(lval *LeoSymType) int
	Error(s string)
}

type LeoParser interface {
	Parse(LeoLexer) int
	Lookahead() int
}

type LeoParserImpl struct {
	lval  LeoSymType
	stack [LeoInitialStackSize]LeoSymType
	char  int
}

func (p *LeoParserImpl) Lookahead() int {
	return p.char
}

func LeoNewParser() LeoParser {
	return &LeoParserImpl{}
}

const LeoFlag = -1000

func LeoTokname(c int) string {
	if c >= 1 && c-1 < len(LeoToknames) {
		if LeoToknames[c-1] != "" {
			return LeoToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func LeoStatname(s int) string {
	if s >= 0 && s < len(LeoStatenames) {
		if LeoStatenames[s] != "" {
			return LeoStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func LeoErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !LeoErrorVerbose {
		return "syntax error"
	}

	for _, e := range LeoErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + LeoTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(LeoPact[state])
	for tok := TOKSTART; tok-1 < len(LeoToknames); tok++ {
		if n := base + tok; n >= 0 && n < LeoLast && int(LeoChk[int(LeoAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if LeoDef[state] == -2 {
		i := 0
		for LeoExca[i] != -1 || int(LeoExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; LeoExca[i] >= 0; i += 2 {
			tok := int(LeoExca[i])
			if tok < TOKSTART || LeoExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if LeoExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += LeoTokname(tok)
	}
	return res
}

func Leolex1(lex LeoLexer, lval *LeoSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(LeoTok1[0])
		goto out
	}
	if char < len(LeoTok1) {
		token = int(LeoTok1[char])
		goto out
	}
	if char >= LeoPrivate {
		if char < LeoPrivate+len(LeoTok2) {
			token = int(LeoTok2[char-LeoPrivate])
			goto out
		}
	}
	for i := 0; i < len(LeoTok3); i += 2 {
		token = int(LeoTok3[i+0])
		if token == char {
			token = int(LeoTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(LeoTok2[1]) /* unknown char */
	}
	if LeoDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", LeoTokname(token), uint(char))
	}
	return char, token
}

func LeoParse(Leolex LeoLexer) int {
	return LeoNewParser().Parse(Leolex)
}

func (Leorcvr *LeoParserImpl) Parse(Leolex LeoLexer) int {
	var Leon int
	var LeoVAL LeoSymType
	var LeoDollar []LeoSymType
	_ = LeoDollar // silence set and not used
	LeoS := Leorcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	Leostate := 0
	Leorcvr.char = -1
	Leotoken := -1 // Leorcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		Leostate = -1
		Leorcvr.char = -1
		Leotoken = -1
	}()
	Leop := -1
	goto Leostack

ret0:
	return 0

ret1:
	return 1

Leostack:
	/* put a state and value onto the stack */
	if LeoDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", LeoTokname(Leotoken), LeoStatname(Leostate))
	}

	Leop++
	if Leop >= len(LeoS) {
		nyys := make([]LeoSymType, len(LeoS)*2)
		copy(nyys, LeoS)
		LeoS = nyys
	}
	LeoS[Leop] = LeoVAL
	LeoS[Leop].yys = Leostate

Leonewstate:
	Leon = int(LeoPact[Leostate])
	if Leon <= LeoFlag {
		goto Leodefault /* simple state */
	}
	if Leorcvr.char < 0 {
		Leorcvr.char, Leotoken = Leolex1(Leolex, &Leorcvr.lval)
	}
	Leon += Leotoken
	if Leon < 0 || Leon >= LeoLast {
		goto Leodefault
	}
	Leon = int(LeoAct[Leon])
	if int(LeoChk[Leon]) == Leotoken { /* valid shift */
		Leorcvr.char = -1
		Leotoken = -1
		LeoVAL = Leorcvr.lval
		Leostate = Leon
		if Errflag > 0 {
			Errflag--
		}
		goto Leostack
	}

Leodefault:
	/* default state action */
	Leon = int(LeoDef[Leostate])
	if Leon == -2 {
		if Leorcvr.char < 0 {
			Leorcvr.char, Leotoken = Leolex1(Leolex, &Leorcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if LeoExca[xi+0] == -1 && int(LeoExca[xi+1]) == Leostate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			Leon = int(LeoExca[xi+0])
			if Leon < 0 || Leon == Leotoken {
				break
			}
		}
		Leon = int(LeoExca[xi+1])
		if Leon < 0 {
			goto ret0
		}
	}
	if Leon == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			Leolex.Error(LeoErrorMessage(Leostate, Leotoken))
			Nerrs++
			if LeoDebug >= 1 {
				__yyfmt__.Printf("%s", LeoStatname(Leostate))
				__yyfmt__.Printf(" saw %s\n", LeoTokname(Leotoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for Leop >= 0 {
				Leon = int(LeoPact[LeoS[Leop].yys]) + LeoErrCode
				if Leon >= 0 && Leon < LeoLast {
					Leostate = int(LeoAct[Leon]) /* simulate a shift of "error" */
					if int(LeoChk[Leostate]) == LeoErrCode {
						goto Leostack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if LeoDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", LeoS[Leop].yys)
				}
				Leop--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if LeoDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", LeoTokname(Leotoken))
			}
			if Leotoken == LeoEofCode {
				goto ret1
			}
			Leorcvr.char = -1
			Leotoken = -1
			goto Leonewstate /* try again in the same state */
		}
	}

	/* reduction by production Leon */
	if LeoDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", Leon, LeoStatname(Leostate))
	}

	Leont := Leon
	Leopt := Leop
	_ = Leopt // guard against "declared and not used"

	Leop -= int(LeoR2[Leon])
	// Leop is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if Leop+1 >= len(LeoS) {
		nyys := make([]LeoSymType, len(LeoS)*2)
		copy(nyys, LeoS)
		LeoS = nyys
	}
	LeoVAL = LeoS[Leop+1]

	/* consult goto table to find next state */
	Leon = int(LeoR1[Leon])
	Leog := int(LeoPgo[Leon])
	Leoj := Leog + LeoS[Leop].yys + 1

	if Leoj >= LeoLast {
		Leostate = int(LeoAct[Leog])
	} else {
		Leostate = int(LeoAct[Leoj])
		if int(LeoChk[Leostate]) != -Leon {
			Leostate = int(LeoAct[Leog])
		}
	}
	// dummy call; replaced with literal code
	switch Leont {

	case 1:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:366
		{
			LeoVAL.Tokennode = NewNode(nil, "terminal", &LeoVAL)
		}
	case 2:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:366
		{
			LeoVAL.Tokennode = NewNode(nil, "terminal", &LeoVAL)
		}
	case 3:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:366
		{
			LeoVAL.Tokennode = NewNode(nil, "terminal", &LeoVAL)
		}
	case 4:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:366
		{
			LeoVAL.Tokennode = NewNode(nil, "terminal", &LeoVAL)
		}
	case 5:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:369
		{
			fmt.Println(" File -> ")
			LeoVAL.Tokennode = NewNode(nil, "file", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 6:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:377
		{
			fmt.Println(" Package -> ")
			LeoVAL.Tokennode = NewNode(nil, "package", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 7:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:383
		{
			fmt.Println(" Import -> ")
			LeoVAL.Tokennode = NewNode(nil, "import", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 8:
		LeoDollar = LeoS[Leopt-0 : Leopt+1]
//line leo.y:389
		{
			LeoVAL.Tokennode = NewNode(nil, "import_list", &LeoVAL)
		}
	case 9:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:389
		{
			LeoVAL.Tokennode = NewNode(nil, "import_list", &LeoVAL)
		}
	case 10:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:390
		{
			LeoVAL.Tokennode = LeoDollar[1].Tokennode
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 11:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:395
		{
			LeoVAL.Tokennode = NewNode(nil, "string_literal", &LeoVAL)
		}
	case 18:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:399
		{
			LeoVAL.Tokennode = NewNode(nil, "top_declaration", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 19:
		LeoDollar = LeoS[Leopt-0 : Leopt+1]
//line leo.y:403
		{
			LeoVAL.Tokennode = NewNode(nil, "top_decl_list", &LeoVAL)
		}
	case 20:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:403
		{
			LeoVAL.Tokennode = NewNode(nil, "top_declaration_list", &LeoVAL)
		}
	case 21:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:404
		{
			LeoVAL.Tokennode = LeoDollar[1].Tokennode
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 22:
		LeoDollar = LeoS[Leopt-7 : Leopt+1]
//line leo.y:410
		{
			LeoVAL.Tokennode = NewNode(nil, "func", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[5].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[7].Tokennode)
		}
	case 23:
		LeoDollar = LeoS[Leopt-0 : Leopt+1]
//line leo.y:418
		{
			LeoVAL.Tokennode = NewNode(nil, "template_params", &LeoVAL)
		}
	case 24:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:419
		{
			LeoVAL.Tokennode = NewNode(nil, "template_params", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 25:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:424
		{
			LeoVAL.Tokennode = NewNode(nil, "return_params", &LeoVAL)
		}
	case 26:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:425
		{
			LeoVAL.Tokennode = NewNode(nil, "return_params", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 27:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:430
		{
			LeoVAL.Tokennode = NewNode(nil, "parameter_list", &LeoVAL)
		}
	case 28:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:431
		{
			LeoVAL.Tokennode = LeoDollar[1].Tokennode
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 29:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:437
		{
			LeoVAL.Tokennode = NewNode(nil, "parameter", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 30:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:444
		{
			LeoVAL.Tokennode = NewNode(nil, "block", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 31:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:449
		{
			LeoVAL.Tokennode = NewNode(nil, "statement_list", &LeoVAL)
		}
	case 32:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:450
		{
			LeoVAL.Tokennode = LeoDollar[1].Tokennode
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 47:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:456
		{
			LeoVAL.Tokennode = NewNode(nil, "statement", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 48:
		LeoDollar = LeoS[Leopt-10 : Leopt+1]
//line leo.y:462
		{
			LeoVAL.Tokennode = NewNode(nil, "method", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[5].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[7].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[9].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[10].Tokennode)
		}
	case 49:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:473
		{
			LeoVAL.Tokennode = NewNode(nil, "var", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 50:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:480
		{
			LeoVAL.Tokennode = NewNode(nil, "const", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 51:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:486
		{
			LeoVAL.Tokennode = NewNode(nil, "type", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 52:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:487
		{
			LeoVAL.Tokennode = NewNode(nil, "type", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 53:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:488
		{
			LeoVAL.Tokennode = NewNode(nil, "type", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 54:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:489
		{
			LeoVAL.Tokennode = NewNode(nil, "type", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 55:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:490
		{
			LeoVAL.Tokennode = NewNode(nil, "type", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 56:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:492
		{
			LeoVAL.Tokennode = NewNode(nil, "symbol", &LeoVAL)
		}
	case 57:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:493
		{
			LeoVAL.Tokennode = LeoDollar[1].Tokennode
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 58:
		LeoDollar = LeoS[Leopt-5 : Leopt+1]
//line leo.y:499
		{
			LeoVAL.Tokennode = NewNode(nil, "struct", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 59:
		LeoDollar = LeoS[Leopt-5 : Leopt+1]
//line leo.y:506
		{
			LeoVAL.Tokennode = NewNode(nil, "interface", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 60:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:512
		{
			LeoVAL.Tokennode = NewNode(nil, "field_list", &LeoVAL)
		}
	case 61:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:513
		{
			LeoVAL.Tokennode = LeoDollar[1].Tokennode
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 62:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:518
		{
			LeoVAL.Tokennode = NewNode(nil, "field", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 63:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:520
		{
			LeoVAL.Tokennode = NewNode(nil, "interface_method_list", &LeoVAL)
		}
	case 64:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:521
		{
			LeoVAL.Tokennode = LeoDollar[1].Tokennode
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 65:
		LeoDollar = LeoS[Leopt-6 : Leopt+1]
//line leo.y:526
		{
			LeoVAL.Tokennode = NewNode(nil, "interface_method", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[6].Tokennode)
		}
	case 66:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:534
		{
			LeoVAL.Tokennode = NewNode(nil, "block", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 67:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:538
		{
			LeoVAL.Tokennode = NewNode(nil, "return", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 68:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:539
		{
			LeoVAL.Tokennode = NewNode(nil, "return", &LeoVAL)
		}
	case 69:
		LeoDollar = LeoS[Leopt-5 : Leopt+1]
//line leo.y:543
		{
			LeoVAL.Tokennode = NewNode(nil, "var_assign", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 70:
		LeoDollar = LeoS[Leopt-5 : Leopt+1]
//line leo.y:549
		{
			LeoVAL.Tokennode = NewNode(nil, "new_assign", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 71:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:555
		{
			LeoVAL.Tokennode = NewNode(nil, "if", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 72:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:556
		{
			LeoVAL.Tokennode = NewNode(nil, "if", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 73:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:559
		{
			LeoVAL.Tokennode = NewNode(nil, "else", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 74:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:560
		{
			LeoVAL.Tokennode = NewNode(nil, "else", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 75:
		LeoDollar = LeoS[Leopt-5 : Leopt+1]
//line leo.y:564
		{
			LeoVAL.Tokennode = NewNode(nil, "switch", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 76:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:569
		{
			LeoVAL.Tokennode = NewNode(nil, "case_list", &LeoVAL)
		}
	case 77:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:570
		{
			LeoVAL.Tokennode = LeoDollar[1].Tokennode
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 78:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:574
		{
			LeoVAL.Tokennode = NewNode(nil, "case_clause", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 79:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:575
		{
			LeoVAL.Tokennode = NewNode(nil, "case_clause", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 80:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:579
		{
			LeoVAL.Tokennode = NewNode(nil, "case_condition", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 81:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:580
		{
			LeoVAL.Tokennode = NewNode(nil, "case_condition", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 82:
		LeoDollar = LeoS[Leopt-5 : Leopt+1]
//line leo.y:586
		{
			LeoVAL.Tokennode = NewNode(nil, "for", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[5].Tokennode)
		}
	case 83:
		LeoDollar = LeoS[Leopt-0 : Leopt+1]
//line leo.y:594
		{
			LeoVAL.Tokennode = NewNode(nil, "for_init", &LeoVAL)
		}
	case 84:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:595
		{
			LeoVAL.Tokennode = NewNode(nil, "for_init", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 85:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:596
		{
			LeoVAL.Tokennode = NewNode(nil, "for_init", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 86:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:597
		{
			LeoVAL.Tokennode = NewNode(nil, "for_init", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 87:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:599
		{
			LeoVAL.Tokennode = NewNode(nil, "for_init", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 88:
		LeoDollar = LeoS[Leopt-0 : Leopt+1]
//line leo.y:603
		{
			LeoVAL.Tokennode = NewNode(nil, "for_cond", &LeoVAL)
		}
	case 89:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:604
		{
			LeoVAL.Tokennode = NewNode(nil, "for_cond", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 90:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:606
		{
			LeoVAL.Tokennode = NewNode(nil, "for_condition", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 91:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:611
		{
			LeoVAL.Tokennode = NewNode(nil, "for_post", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 92:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:613
		{
			LeoVAL.Tokennode = NewNode(nil, "for_post", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 93:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:618
		{
			LeoVAL.Tokennode = NewNode(nil, "range", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 94:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:624
		{
			LeoVAL.Tokennode = NewNode(nil, "break", &LeoVAL)
		}
	case 95:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:628
		{
			LeoVAL.Tokennode = NewNode(nil, "continue", &LeoVAL)
		}
	case 96:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:632
		{
			LeoVAL.Tokennode = NewNode(nil, "goto", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 97:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:637
		{
			LeoVAL.Tokennode = NewNode(nil, "fallthrough", &LeoVAL)
		}
	case 98:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:641
		{
			LeoVAL.Tokennode = NewNode(nil, "safe", &LeoVAL)
		}
	case 113:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:645
		{
			LeoVAL.Tokennode = NewNode(nil, "expr", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 114:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:649
		{
			LeoVAL.Tokennode = NewNode(nil, "unary_expr", &LeoVAL)
		}
	case 115:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:650
		{
			LeoVAL.Tokennode = NewNode(nil, "unary_expr", &LeoVAL)
		}
	case 116:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:651
		{
			LeoVAL.Tokennode = NewNode(nil, "unary_expr", &LeoVAL)
		}
	case 121:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:654
		{
			LeoVAL.Tokennode = NewNode(nil, "binary_expr", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 129:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:660
		{
			LeoVAL.Tokennode = NewNode(nil, "ternary_expr", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 137:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:666
		{
			LeoVAL.Tokennode = NewNode(nil, "assign_expr", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 138:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:672
		{
			LeoVAL.Tokennode = NewNode(nil, "new_assign_expr", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 139:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:678
		{
			LeoVAL.Tokennode = NewNode(nil, "accessor_expr", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 140:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:684
		{
			LeoVAL.Tokennode = NewNode(nil, "index_expr", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 141:
		LeoDollar = LeoS[Leopt-6 : Leopt+1]
//line leo.y:690
		{
			LeoVAL.Tokennode = NewNode(nil, "slice_expr", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[5].Tokennode)
		}
	case 142:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:697
		{
			LeoVAL.Tokennode = NewNode(nil, "call_expr", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 143:
		LeoDollar = LeoS[Leopt-5 : Leopt+1]
//line leo.y:706
		{
			LeoVAL.Tokennode = NewNode(nil, "map", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[5].Tokennode)
		}
	case 144:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:712
		{
			LeoVAL.Tokennode = NewNode(nil, "array_index", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 145:
		LeoDollar = LeoS[Leopt-5 : Leopt+1]
//line leo.y:718
		{
			LeoVAL.Tokennode = NewNode(nil, "slice_index", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 146:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:725
		{
			LeoVAL.Tokennode = NewNode(nil, "for_range", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 147:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:731
		{
			LeoVAL.Tokennode = NewNode(nil, "range_expr", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 148:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:740
		{
			LeoVAL.Tokennode = NewNode(nil, "channel", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 149:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:746
		{
			LeoVAL.Tokennode = NewNode(nil, "channel_send", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 150:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:753
		{
			LeoVAL.Tokennode = NewNode(nil, "channel_receive", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 151:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:764
		{
			LeoVAL.Tokennode = NewNode(nil, "bridge", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 152:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:771
		{
			LeoVAL.Tokennode = NewNode(nil, "transfer", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 153:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:778
		{
			LeoVAL.Tokennode = NewNode(nil, "return", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 154:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:784
		{
			LeoVAL.Tokennode = NewNode(nil, "group_expr", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 155:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:790
		{
			LeoVAL.Tokennode = NewNode(nil, "argument", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
		}
	case 156:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:795
		{
			LeoVAL.Tokennode = NewNode(nil, "argument_list", &LeoVAL)
		}
	case 157:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:796
		{
			LeoVAL.Tokennode = LeoDollar[1].Tokennode
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 158:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:801
		{
			LeoVAL.Tokennode = NewNode(nil, "symbol_list", &LeoVAL)
		}
	case 159:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:802
		{
			LeoVAL.Tokennode = LeoDollar[1].Tokennode
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 160:
		LeoDollar = LeoS[Leopt-1 : Leopt+1]
//line leo.y:808
		{
			LeoVAL.Tokennode = NewNode(nil, "id", &LeoVAL)
		}
	case 161:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:813
		{
			LeoVAL.Tokennode = NewNode(nil, "add_assign_expr", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[1].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 162:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:820
		{
			LeoVAL.Tokennode = NewNode(nil, "default", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 163:
		LeoDollar = LeoS[Leopt-4 : Leopt+1]
//line leo.y:826
		{
			LeoVAL.Tokennode = NewNode(nil, "case", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 164:
		LeoDollar = LeoS[Leopt-2 : Leopt+1]
//line leo.y:833
		{
			LeoVAL.Tokennode = NewNode(nil, "launch", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 165:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:839
		{
			LeoVAL.Tokennode = NewNode(nil, "select", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	case 166:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:846
		{
			LeoVAL.Tokennode = NewNode(nil, "array_declaration", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
		}
	case 167:
		LeoDollar = LeoS[Leopt-5 : Leopt+1]
//line leo.y:852
		{
			LeoVAL.Tokennode = NewNode(nil, "slice_declaration", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[2].Tokennode)
			LeoVAL.Tokennode.AddChild(LeoDollar[4].Tokennode)
		}
	case 168:
		LeoDollar = LeoS[Leopt-3 : Leopt+1]
//line leo.y:859
		{
			LeoVAL.Tokennode = NewNode(nil, "default_clause", &LeoVAL)
			LeoVAL.Tokennode.AddChild(LeoDollar[3].Tokennode)
		}
	}
	goto Leostack /* stack new state and value */
}
